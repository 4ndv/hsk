{"version":3,"file":"static/webpack/static/development/pages/learn.js.7dc432669eb0b6152cf3.hot-update.js","sources":["webpack:///./lib/learn.js","webpack:///./node_modules/lodash/slice.js"],"sourcesContent":["import random from 'lodash/random'\nimport uniq from 'lodash/uniq'\nimport map from 'lodash/map'\nimport sample from 'lodash/sample'\nimport shuffle from 'lodash/shuffle'\nimport slice from 'lodash/slice'\nimport flatten from 'lodash/flatten'\n\nimport hsk1 from '~/words/hsk1'\nimport hsk2 from '~/words/hsk2'\nimport hsk3 from '~/words/hsk3'\nimport hsk4 from '~/words/hsk4'\nimport hsk5 from '~/words/hsk5'\nimport hsk6 from '~/words/hsk6'\n\nexport function levelWords(level) {\n  switch (level) {\n    case 1:\n      return hsk1\n    case 2:\n      return hsk2\n    case 3:\n      return hsk3\n    case 4:\n      return hsk4\n    case 5:\n      return hsk5\n    case 6:\n      return hsk6\n    default:\n      return {}\n  }\n}\n\nexport function nRandomDigitsWithoutRepetitionExcluding(count, max, exclude) {\n  const digits = []\n\n  while (uniq(digits).length !== count) {\n    const digit = random(0, max)\n\n    if (digit !== exclude) digits.push(digit)\n  }\n\n  return uniq(digits)\n}\n\nexport function selectNWords(words, count, exclude) {\n  return map(\n    nRandomDigitsWithoutRepetitionExcluding(count, words.length - 1, exclude),\n    (d) => words[d]\n  )\n}\n\nexport function buildFromConfig(config) {\n  const data = shuffle(\n    flatten(\n      config.levels.map((level) => {\n        const words = levelWords(level)\n\n        return map(words, (word, index) => {\n          const variants = [word, ...selectNWords(words, 3, index)]\n\n          return {\n            type: sample(config.modes),\n            question: word,\n            variants: shuffle(variants)\n          }\n        })\n      })\n    )\n  )\n\n  if (+config.wordsLimit > 0) {\n    return slice(data, 0, +config.wordsLimit)\n  }\n\n  return data\n}\n","var baseSlice = require('./_baseSlice'),\n    isIterateeCall = require('./_isIterateeCall'),\n    toInteger = require('./toInteger');\n\n/**\n * Creates a slice of `array` from `start` up to, but not including, `end`.\n *\n * **Note:** This method is used instead of\n * [`Array#slice`](https://mdn.io/Array/slice) to ensure dense arrays are\n * returned.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Array\n * @param {Array} array The array to slice.\n * @param {number} [start=0] The start position.\n * @param {number} [end=array.length] The end position.\n * @returns {Array} Returns the slice of `array`.\n */\nfunction slice(array, start, end) {\n  var length = array == null ? 0 : array.length;\n  if (!length) {\n    return [];\n  }\n  if (end && typeof end != 'number' && isIterateeCall(array, start, end)) {\n    start = 0;\n    end = length;\n  }\n  else {\n    start = start == null ? 0 : toInteger(start);\n    end = end === undefined ? length : toInteger(end);\n  }\n  return baseSlice(array, start, end);\n}\n\nmodule.exports = slice;\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AAdA;AAgBA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAAA;AAEA;AAEA;AACA;AAGA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAHA;AAKA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC7EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;A","sourceRoot":""}